\section{Alberi Binari di Ricerca}
\paragraph{Albero binario:} struttura di dati ad albero composta da nodi, ognuno dei quali ha al massimo due figli, chiamati nodo destro e nodo sinistro. L'albero inizia con un singolo nodo, noto come radice. \\~\\

Matematicamente:
\begin{itemize}
    \item nodi $x$ ed elemento/valore/chiave $x.key$
    \item operazioni hanno costo $O(h)$ quando non bilanciato, $O(\log(n))$ se bilanciato
\end{itemize}

\paragraph{Definizione induttiva:}
\begin{itemize}
    \item $\varnothing$ è un albero
    \item se $r$ è un nodo, $T_1$ e $T_2$ alberi $\Rightarrow r(T_1,T_2)$ è un albero
    \item ogni nodo $x$ ha i seguenti campi:
    \begin{itemize}
        \item $x.p$
        \item $x.key$
        \item $x.left$
        \item $x.right$
    \end{itemize}
\end{itemize}

\paragraph{Operazioni possibili:}
\begin{itemize}
    \item Visita simmetrica (InOrder)
    \item Ricerca (Search)
    \item Ricerca di min e max
    \item Successore
    \item Inserimento
    \item Cancellazione
\end{itemize}

\subsection{Visita simmetrica (InOrder)}
Elencare gli elementi del sottoalbero radicato in un nodo $x$ in ordine di chiave crescente.
\begin{mdframed}
\begin{lstlisting}[language=C]
IN-ORDER(x)
1   if x != NULL
2       IN-ORDER(x.left)
3       print(x)
4       IN-ORDER(x.right)
\end{lstlisting}
\end{mdframed}
La complessità di tale operazione è lineare, dato da una visita di tutto l'albero.
\begin{equation*}
    T(n) = \begin{cases}
        c \qquad(n=0)\\
        T(k) + T(n-k-1) + d \qquad(n>0, k<n)
    \end{cases}
\end{equation*}
Stima di complessità: $T(n) = (c+d)n + c$

\newpage
\subsection{Ricerca (Search)}
Data $k$ chiave, cerca nel sottoalbero radicato nel nodo $x$ un nodo con chiave $k$.
\begin{mdframed}
\begin{lstlisting}[language=C]
SEARCH(x,k)
1   if (x == NULL) or (x.key == k)
2       return x
3   else if (k < x.key)
4       return SEARCH(x.left,k)
5   else
6       return SEARCH(x.right,k)
\end{lstlisting}
\end{mdframed}
La complessità, nel caso peggiore, è la ricerca che continua fino ad una foglia ed il cammino radice-foglia è quello massimo. Complessità: $O(h)$.
\begin{mdframed}
\begin{lstlisting}[language=C]
SEARCH(x,k)
1   while (x != NULL) and (x.key != k)
2       if (k < x.key)
3           x = x.left
4       else
5           x = x.right
6   return x
\end{lstlisting}
\end{mdframed}
Se dobbiamo esaminare tutto l'albero, nel caso peggiore avremo una complessità $\Theta(n)$ sulla base di una relazione di ricorrenza $T(n) = c + T(k) + T(n-k-1)$. 
